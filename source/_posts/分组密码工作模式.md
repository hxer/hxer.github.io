---
title: 分组密码工作模式
date: 2017-03-06 14:14:41
categories:
    - 密码学
tags:
    - ECB
    - CBC
    - 分组加密
---

在密码学中，分组加密(Block cipher)，又称分块加密或块密码，是一种对称密钥算法。 它将明文分成多个等长的模块(block)，使用确定的算法和对称密钥对每组分别加密解密。

常见的分组加密算法有: DES、3DES、AES、IDEA。

<!-- more -->

## 工作模式

参考: [维基百科](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)

分组密码算法只能加密`固定长度`的分组，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适`填充方式`将数据扩展到匹配密码块大小的长度。对于变长数据需要对分组密码算法进行迭代，以便将明文全部加密。而迭代的方法就称为分组密码的模式（mode），主要有以下模式：

* ECB模式：Electronic CodeBook mode（电子密码模式）
* CBC模式：Cipher Block Chaining mode（密码分组链接模式）
* CFB模式：Cipher FeedBack mode（密文反馈模式）
* OFB模式：Output FeedBack mode（输出反馈模式）
* CTR模式：CounTeR mode（计数器模式）

常见分组密码算法分组长度和秘钥长度如下表:

| 密码算法 | 分组长度 | 秘钥长度 |
| ---- | ----- | ----- |
| DES | 64 bit/8 byte | 64(56+8) bit/8 byte |
| 3DES | 64 bit/8 byte |  64/64\*2/64\*3 bit |
| AES | 128 bit/16 byte | 128/192/256 bit |

一般采用的填充方式有如下几种:

* ANSIX923

ANSIX923 填充字符串由一个字节序列组成，此字节序列的最后一个字节填充字节序列的长度，其余字节均填充数字零。
假定块长度为8，数据长度为 9，数据： FF FF FF FF FF FF FF FF FF，填充： FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07

* ISO10126

ISO10126 填充字符串由一个字节序列组成，此字节序列的最后一个字节填充字节序列的长度，其余字节填充随机数据。
假定块长度为 8，数据长度为 9，数据： FF FF FF FF FF FF FF FF FF，填充： FF FF FF FF FF FF FF FF FF 7D 2A 75 EF F8 EF 07

* PKCS7

PKCS7 填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。
假定块长度为 8，数据长度为 9，数据： FF FF FF FF FF FF FF FF FF，填充： FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07，如果恰好8个字节时还要补8个字节的0x08，可以让解密的数据很确定无误的移除多余的字节。 PKCS5Padding 和 PKCS7Padding 在这方面是类似的。不同点在于，选择算法的时候如果选用 PKCS5Padding 填充模式，就是明确指定块大小是 8 个字节。选用 PKCS7Padding 则是没有明确指定块大小。如果选择算法的时候选用 PKCS7Padding 填充模式，同时设置块大小为 8 字节，和选用 PKCS5Padding 填充模式，没有设置块大小（实际已经设置了 8 字节），这两种情况下，两种填充模式没有区别。另外有个值得注意的是，AES 中块大小是固定 16 字节。

* Zeros

填充字符串由设置为零的字节组成

## ECB

ECB 将需要加密的明文按照块密码的块大小分为若干块，并对每个块独立进行加密，加密和解密过程如下:

{% asset_img Mode_ECB_Enc.png %}
{% asset_img Mode_ECB_Dec.png %}

ECB模式中，明文和密文是一一对应的，相同的明文分组加密将会得到相应的密文分组。因此，它不能很好的隐藏数据模式。同时还存在安全风险，容易受到重放攻击, 改变密文分组的顺序，可以改变解密后明文分组的顺序。

| 优点 | 缺点 |
| ---- | ---- |
| 简单 | 不能隐藏明文的模式 |
| 利于并行计算 | 可能对明文进行主动攻击 |
| 不会传递误差 | |

## CBC

CBC模式加密，先将明文分组与前一个密文分组(或为初始化向量IV)进行XOR运算，然后再进行加密；解密，密文分组先进行解密，然后再进行xor运算得到明文分组。

{% asset_img Mode_CBC_Enc.png %}
{% asset_img Mode_CBC_Dec.png %}

CBC加密，每个密文块都依赖于它前面所有的明文块，这有效解决了ECB模式中泄露明文模式的问题，但同时明文块的误差会传播到后面所有的密文块。

| 优点 | 缺点 |
| ---- | ---- |
| 安全性好于ECB | 误差传递 |
| 隐藏了明文模式 | 不利于并行计算 |
|  | 需要初始化向量IV |

### 翻转攻击

CBC解密可以用如下式子表示：

* Plaintext-1 = Decrypt(Ciphertext-1) XOR IV  只用于第一个组块
* Plaintext-N = Decrypt(Ciphertext-N) XOR Ciphertext-N-1   用于第二及剩下的组块

改变IV的值，只会影响解密出的第一组明文，而改变密文中的`一位`只会导致其对应的明文块完全改变，下一个明文块中的`对应位`发生改变，而不会影响到其它明文块的内容。
因此，修改IV可以操纵解密出的第一组明文，修改某一个密文分组可以操纵后一个解密出的明文分组，也就是说CBC模式存在两个攻击点：

* IV向量，影响第一个明文分组
* 第N个密文分组, 影响第N+1个明文分组


### 攻击场景

常见的攻击场景有权限提升和验证绕过

## CFB

CFB模式可以看做是一种使用分组密码来实现流密码的方式, CFB模式中由密码算法所生成的比特序列称为密钥流（key stream）。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的“种子”， 它的明文数据可以被逐比特加密。

{% asset_img Mode_CFB_Enc.png %}
{% asset_img Mode_CFB_Dec.png %}

| 优点 | 缺点 |
| ---- | ---- |
| 分组密码转化为流模式 | 误差传递 |
| 隐藏了明文模式 | 不利于并行计算 |
| 可以及时加密传送小于分组的数据 | 需要初始化向量IV |

### 重放攻击

{% asset_img Mode_CFB_ReplayAttack.png %}

## OFB

OFB模式中，密码算法的输出会反馈到密码算法的输入中。OFB模式不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行XOR来产生“密文分组”的

{% asset_img Mode_OFB_Enc.png %}
{% asset_img Mode_OFB_Dec.png %}

## CTR

CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的

{% asset_img Mode_CTR_Enc.png %}
{% asset_img Mode_CTR_Dec.png %}

### 特点

* 加密和解密使用了完全相同的结构，程序实现上比较容易
* 可以以任意顺序对分组进行加密和解密
* 不会放大错误，假设CTR模式的密文分组中有一个比特被翻转了，则解密后明文分组中仅有与之对应的比特会被翻转，这一错误不会放大
